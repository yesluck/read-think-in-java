## 10 内部类

### 10.1 创建内部类
把类的定义置于外围类的里面。
更典型的情况是，外部类将有一个方法，该方法返回一个指向内部类的引用。

如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么必须像在``main()``方法中那样具体指明这个对象的类型：``OuterlassName.InnerClassName``

### 10.2 链接到外部类
内部类对象能访问其外围对象的所有成员，内部类拥有其外围类所有元素的访问权。

这是如何做到的呢？
当某个外围类的对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用（编译器处理所有细节）。然后，当你访问此外围类的成员时，就是用那个引用来选择外围类的成员。
- 内部类的对象只能在与其外围类的对象相关联的情况下才能被创建（内部类非static！）。

### 10.3 使用.this和.new
生成对外部类对象的引用：使用外部类的名字后面紧跟.this
```
public class DotThis {
    public class Inner {
        public DotThis outer() {
            return DotThis.this;
        }
    }
}
```
创建某个内部类的对象：在``new``表达式中提供对其他外部类对象的引用（不能按照你想象的方式去引用外部类的名字``DotNew``，而是必须使用外部类的**对象**(``dn``)来创建该内部类**对象**(``dni``)）
```
public class DotNew {
    public class Inner {}
    public static void main(String[] args) {
        DotNew dn = new DotNew();
        DotNew.Inner dni = dn.new Inner();  // this line
    }
}
```

### 10.4 内部类与向上转型
当将内部类向上转型为基类，尤其是转型为一个接口的时候，此内部类能够完全不可见并且不可用。所得到的只是指向基类或接口的引用，所以能够很方便地隐藏实现细节。

例如：
```
public interface Contents {
  int value();
} ///:~

public interface Destination {
  String readLabel();
} ///:~


class Parcel4 {
  private class PContents implements Contents {
    private int i = 11;
    public int value() { return i; }
  }
  protected class PDestination implements Destination {
    private String label;
    private PDestination(String whereTo) {
      label = whereTo;
    }
    public String readLabel() { return label; }
  }
  public Destination destination(String s) {
    return new PDestination(s);
  }
  public Contents contents() {
    return new PContents();
  }
}

public class TestParcel {
  public static void main(String[] args) {
    Parcel4 p = new Parcel4();
    Contents c = p.contents();
    Destination d = p.destination("Tasmania");
    // Illegal -- can't access private class:
    //! Parcel4.PContents pc = p.new PContents();
  }
} ///:~

```
个人理解：在这里，内部类``PContents``为private，因此不能被其他类直接访问。这使得其他类只需要调用``Parcel``类的``contents()``接口函数，而完全不需要管这个接口函数是怎么实现的，也完全无法访问这个接口函数的实际实现``PContents``。

### 10.5 在方法和作用域内的内部类
在方法的作用域内创建一个完整的类，被称为局部内部类。在定义该内部类的作用域之外，它是不可用的；除此之外，它和普通的类一样。

### 10.6 匿名内部类
创建一个继承自``Contents``的匿名类的对象：
```
public class Parcel7 {
  public Contents contents() {
    return new Contents() { // Insert a class definition
      private int i = 11;
      public int value() { return i; }
    }; // Semicolon required in this case
  }
  public static void main(String[] args) {
    Parcel7 p = new Parcel7();
    Contents c = p.contents();
  }
} ///:~
```
等价于：
```
public class Parcel7b {
  class MyContents implements Contents {
    private int i = 11;
    public int value() { return i; }
  }
  public Contents contents() { return new MyContents(); }
  public static void main(String[] args) {
    Parcel7b p = new Parcel7b();
    Contents c = p.contents();
  }
} ///:~
```

基类需要一个有参数的构造器：
```
public class Parcel8 {
  public Wrapping wrapping(int x) {
    // Base constructor call:
    return new Wrapping(x) { // Pass constructor argument.
      public int value() {
        return super.value() * 47;
      }
    }; // Semicolon required
  }
  public static void main(String[] args) {
    Parcel8 p = new Parcel8();
    Wrapping w = p.wrapping(10);
  }
} ///:~
```

P198

