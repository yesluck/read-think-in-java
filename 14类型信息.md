## 14 类型信息

运行时类型信息使得你可以在程序运行时发现和使用类型信息。

### 14.1 为什么需要RTTI
RTTI：Run-time type information，在运行时，识别一个动态的类型。

在Java中，所有的类型转换都是在运行时进行正确性检查的。

### 14.2 Class对象
类是程序的一部分，每个类都有一个Class对象。换言之，每当编写并且编译了一个新类，就会产生一个Class对象（被保存在一个同名的.class文件中）。

为了生成这个类的对象，运行这个程序的JVM将使用被称为“**类加载器**”的子系统。

所有的类都是在对其第一次使用时，**动态加载**到JVM中的。当程序创建第一个对类的静态成员的引用时，就会加载这个类。（对比：C++静态加载语言）

类加载器首先检查这个类的Class对象是否已经加载。如果尚未加载，默认的类加载器就会根据类名查找.class文件，并接受验证确保没被损坏或包含不良Java代码。

一旦某个类的Class对象被载入内存，它就被用来创建这个类的所有对象。

``Class.forName("Gum")``中，``forName()``是取得Class对象的引用的一种方法。如果类还没被加载就加载它，在加载的过程中，类的static字句会被执行。如果找不到，会抛出``ClassNotFoundException``。

``Class``方法：``getName()``, ``isInterface()``, ``getSimpleName()``, ``getCanonicalName()``, ``getInterfaces()``, ``getSuperclass()``, ``newInstance()``。

``Class``的``newInstance()``方法是实现“虚拟构造器”的一种途径，调用它的对象仅仅是一个Class引用，在编译期并不具备更进一步的类型信息；调用得到的结果是一个Object引用，但指向Toy类对象。

#### 14.2.1 类字面常量
另一种方法生成对``Class``对象的引用：类字面常量。``FancyToy.class``。
- 简单、安全，因为编译时就会受到检查
- 根除了对``forName()``的调用，所以更高效

当使用``.class``来创建对``Class``对象的引用时，不会自动初始化该``Class``对象。为了使用类而做的准备工作实际上包含三个步骤：
1. 加载：由类加载器执行。查找字节码，并从这些字节码创建一个``Class``对象。
1. 链接：验证类中的字节码，为静态域分配存储空间。如果必需的话，解析这个类创建的对其他类的所有引用。
1. 初始化：如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。初始化被延迟到了对静态方法或者非常数静态域进行首次引用时才执行。

[参考知乎文章](https://zhuanlan.zhihu.com/p/52280079)

- 如果一个``static final``值是“编译期常量”，那么不需要对类进行初始化就可以被读取。
- 如果一个``static``域不是``final``的，那么在对它访问时，总是要求在它被读取之前，要先进行链接和初始化。

#### 14.2.2 泛化的Class引用
``Class<?> intClass = int.class`` 在使用泛化的Class引用时放松限制，使用通配符。
``Class<? extends Number> bounded = int.class`` 限定了类型范围

【P321回看】

#### 14.2.3 新的转型语法
``cast()``方法：接受参数对象，并将其转型为Class引用的类型。
```
Building b = new House();
Class<House> houseType = House.class;
House h = houseType.cast(b);    // or just do this: h = (House)b;
```

### 14.3 类型转换前先做检查

……

